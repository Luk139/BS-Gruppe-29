/* *  Echo-Server * * * */#include "main.h"#define SEGSIZE (sizeof(Key)*STORESIZE)//  Opened Ports in the Docker Container, or whatelse is used for the host-system#define PORT_NUMBER 5678bool exclusive = false;// sharMemId for shared memory segmentint sharMemId;//File-Descriptor Rendezvous und Connectint rndvz_fd;int messageQueueID;Key *sharMem = NULL;void freeIPC(){    shmdt(sharMem);    shmctl(sharMemId, IPC_RMID, 0);    msgctl(messageQueueID, IPC_RMID, NULL);}void initIPC () {    if ((sharMemId = shmget(IPC_PRIVATE, SEGSIZE, IPC_CREAT | 0600)) < 0){        majorError("Error while shmget()");    }    /* Attach the Shared Memory     * (Key *) = Typecast to keypointer     * shmid = integer for the sharedmemory     * shmaddr = for choosing the address of the memory, 0 for the os to choose it itself     * shmflg = 0 for read/write allowance for the shared memory     */    if ((sharMem = (Key *) shmat(sharMemId, 0, 0)) < 0) {        majorError("Error while shmat()");    }    // Empty the random values in the shared memory    // s = sharmem specifies the first address to be overwritten    // c = 0 => set all adresses of the specified memory to 0    // n = SEGSIZE specifies the size, starting from the first address    memset(sharMem, 0, SEGSIZE);    //  Struct for the connection between client and server    struct sockaddr_in client;    //Length of the Client-Data    socklen_t client_len = sizeof(client);    /*  Creating the socket with ipv4 and tcp no further description for protocol needed so 0 is enough -> SOCK_STREAM uses tcp by default.    *   AF_INET = ipv4    *   SOCK_STREAM = tcp    *   protocol 0 = default (For other protocols to expect when working with ip)    */    rndvz_fd = socket(AF_INET, SOCK_STREAM, 0);    //  Return value of rndzvs_fd is negative when an error occurs. And 0 when successfull. If it wasn't successfull terminate program    if (rndvz_fd < 0) {        majorError("Error while socket()");    }    // Set Option for the Socket for rapid iterative binding to adress    int option = 1;    setsockopt(rndvz_fd, SOL_SOCKET, SO_REUSEADDR, (const void *) &option, sizeof(int));    //  Struct for the connection between client and server    struct sockaddr_in server;    //  Define to use ipv4    server.sin_family = AF_INET;    //  Define from which ip-address clients want to connect to server, any adress is allowed    server.sin_addr.s_addr = INADDR_ANY;    //  Define port number on which the client wants to connect    server.sin_port = htons(PORT_NUMBER);    /*  Bind an address to the socket     *  rndzvs_fd = socket file descriptor     *  addr = address struct for cast     *  len = length of the adress     */    int bnd_result = bind(rndvz_fd, (struct sockaddr *) &server, sizeof(server));    // Ask for return value of the function to check for error while binding => terminate program if error    if (bnd_result < 0) {        majorError("Error while bind()");    }    //  Max. capacity for Queue    const int max_clients = 5;    /*  Bring socket to listen for incoming connections and put then in a queue     *  rndzvs_fd = socket file descriptor     *  n = maximum number of clients     *     */    int lstn_result = listen(rndvz_fd, max_clients);    // Check return value for error    if (lstn_result < 0) {        majorError("Error while listen()");    }    messageQueueID = msgget(IPC_PRIVATE, IPC_CREAT | 0666);    if(messageQueueID < 0){        majorError("Error while msgget()");    }}int main(){    initIPC();    initializeSem();    parentLoop(rndvz_fd);    closeSemaphore();    freeIPC();}